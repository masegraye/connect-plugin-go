# KV Example Walkthrough

Complete walkthrough of the KV (Key-Value) example plugin included in the repository.

## Overview

The KV example demonstrates:

- Defining a plugin interface in protobuf
- Generating plugin code
- Implementing the plugin server
- Using the plugin from a host application
- Building and running both sides

Location: `examples/kv/`

## Step 1: Proto Definition

**File: `examples/kv/proto/kv.proto`**

```protobuf
syntax = "proto3";

package kv.v1;

option go_package = "github.com/masegraye/connect-plugin-go/examples/kv/gen;kv";

service KVService {
  rpc Get(GetRequest) returns (GetResponse);
  rpc Set(SetRequest) returns (SetResponse);
  rpc Delete(DeleteRequest) returns (DeleteResponse);
  rpc List(ListRequest) returns (ListResponse);
}

message GetRequest {
  string key = 1;
}

message GetResponse {
  string value = 1;
  bool found = 2;
}

message SetRequest {
  string key = 1;
  string value = 2;
}

message SetResponse {}

message DeleteRequest {
  string key = 1;
}

message DeleteResponse {
  bool deleted = 1;
}

message ListRequest {}

message ListResponse {
  repeated string keys = 1;
}
```

## Step 2: Generate Code

```bash
task proto
```

This generates:

- `examples/kv/gen/kv.pb.go` - Protobuf types
- `examples/kv/gen/kvv1connect/kv.connect.go` - Connect client/server
- `examples/kv/gen/kvv1plugin/plugin.go` - Plugin wrapper

**Generated plugin wrapper:**

```go
// Auto-generated by protoc-gen-connect-plugin
type KVServicePlugin struct{}

func (p *KVServicePlugin) Metadata() connectplugin.PluginMetadata {
    return connectplugin.PluginMetadata{
        Name:    "kv",
        Path:    kvv1connect.KVServiceName,
        Version: "1.0.0",
        Provides: []connectplugin.ServiceDeclaration{
            {
                Type:    "kv",
                Version: "1.0.0",
                Path:    kvv1connect.KVServiceName,
            },
        },
    }
}

func (p *KVServicePlugin) ConnectServer(impl any) (string, http.Handler, error) {
    handler, ok := impl.(kvv1connect.KVServiceHandler)
    // ... creates Connect handler
}

func (p *KVServicePlugin) ConnectClient(baseURL string, httpClient connect.HTTPClient) (any, error) {
    return kvv1connect.NewKVServiceClient(httpClient, baseURL), nil
}
```

## Step 3: Implement the Service

**File: `examples/kv/impl/store.go`**

```go
package impl

import (
    "context"
    "sync"

    "connectrpc.com/connect"
    kv "github.com/masegraye/connect-plugin-go/examples/kv/gen"
)

type KVStore struct {
    mu   sync.RWMutex
    data map[string]string
}

func NewKVStore() *KVStore {
    return &KVStore{
        data: make(map[string]string),
    }
}

func (s *KVStore) Get(
    ctx context.Context,
    req *connect.Request[kv.GetRequest],
) (*connect.Response[kv.GetResponse], error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    value, found := s.data[req.Msg.Key]
    return connect.NewResponse(&kv.GetResponse{
        Value: value,
        Found: found,
    }), nil
}

func (s *KVStore) Set(
    ctx context.Context,
    req *connect.Request[kv.SetRequest],
) (*connect.Response[kv.SetResponse], error) {
    s.mu.Lock()
    defer s.mu.Unlock()

    s.data[req.Msg.Key] = req.Msg.Value
    return connect.NewResponse(&kv.SetResponse{}), nil
}

// ... Delete, List implementations
```

## Step 4: Create Plugin Server

**File: `examples/kv/server/main.go`**

```go
package main

import (
    "log"

    connectplugin "github.com/masegraye/connect-plugin-go"
    "github.com/masegraye/connect-plugin-go/examples/kv/impl"
    "github.com/masegraye/connect-plugin-go/examples/kv/gen/kvv1plugin"
)

func main() {
    // Create KV implementation
    store := impl.NewKVStore()

    // Serve plugin
    server := connectplugin.Serve(&connectplugin.ServeConfig{
        Plugins: connectplugin.PluginSet{
            "kv": &kvv1plugin.KVServicePlugin{},
        },
        Impls: map[string]any{
            "kv": store,
        },
    })

    log.Println("KV plugin server listening on :8080")
    server.Wait()
}
```

## Step 5: Create Host Application

**File: `examples/kv/host/main.go`**

```go
package main

import (
    "context"
    "fmt"
    "log"

    connectplugin "github.com/masegraye/connect-plugin-go"
    kv "github.com/masegraye/connect-plugin-go/examples/kv/gen"
    "github.com/masegraye/connect-plugin-go/examples/kv/gen/kvv1plugin"
)

func main() {
    // Connect to plugin server
    client, err := connectplugin.NewClient(connectplugin.ClientConfig{
        Endpoint: "http://localhost:8080",
        Plugins: connectplugin.PluginSet{
            "kv": &kvv1plugin.KVServicePlugin{},
        },
    })
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()

    // Get typed KV client
    kvClient := connectplugin.MustDispenseTyped[kv.KVServiceClient](client, "kv")

    ctx := context.Background()

    // Set some values
    kvClient.Set(ctx, &kv.SetRequest{Key: "name", Value: "Alice"})
    kvClient.Set(ctx, &kv.SetRequest{Key: "age", Value: "30"})

    // Get a value
    resp, err := kvClient.Get(ctx, &kv.GetRequest{Key: "name"})
    if err != nil {
        log.Fatal(err)
    }

    if resp.Msg.Found {
        fmt.Printf("name = %s\n", resp.Msg.Value)
    }

    // List all keys
    listResp, _ := kvClient.List(ctx, &kv.ListRequest{})
    fmt.Printf("Keys: %v\n", listResp.Msg.Keys)
}
```

## Running the Example

### Build binaries:

```bash
task build-examples
```

Builds to `dist/`:
- `dist/kv-server` - Plugin server
- `dist/kv-host` - Host client

### Terminal 1: Start Plugin Server

```bash
task example:server
```

Output:
```
KV plugin server listening on :8080
```

### Terminal 2: Run Host Client

```bash
task example:client
```

Output:
```
name = Alice
Keys: [name age]
```

## Integration Testing

The example includes integration tests using the test harness:

```bash
task integ:kv:test
```

This:
1. Starts `kv-server` in background
2. Waits for server ready
3. Runs `kv-host` client
4. Ensures server cleanup (even on failure)

## Advanced: KV with Logger Capability

The example also shows using host capabilities (bidirectional calls):

**File: `examples/kv/impl-with-logger/store.go`**

```go
func (s *KVStore) Set(
    ctx context.Context,
    req *connect.Request[kv.SetRequest],
) (*connect.Response[kv.SetResponse], error) {
    s.mu.Lock()
    defer s.mu.Unlock()

    // Log the operation using host capability
    if s.logger != nil {
        s.logger.Log(ctx, &loggerv1.LogRequest{
            Level:   "INFO",
            Message: fmt.Sprintf("SET %s=%s", req.Msg.Key, req.Msg.Value),
        })
    }

    s.data[req.Msg.Key] = req.Msg.Value
    return connect.NewResponse(&kv.SetResponse{}), nil
}
```

Host provides logger capability:

```go
server := connectplugin.Serve(&connectplugin.ServeConfig{
    Plugins: pluginSet,
    Impls:   impls,
    Capabilities: map[string]*connectplugin.Capability{
        "logger": {
            Type:     "logger",
            Version:  "1.0.0",
            Endpoint: "/capabilities/logger",
        },
    },
    CapabilityHandlers: map[string]http.Handler{
        "logger": loggerHandler,
    },
})
```

## Key Takeaways

1. **Proto defines interface**: Single source of truth
2. **Code generation**: Type-safe, no manual wiring
3. **Plugin wrapper**: Auto-generated from proto
4. **Separate processes**: Plugin and host are independent
5. **HTTP-based**: Standard HTTP/2, works with proxies/load balancers
6. **Type safety**: No `interface{}` casting needed

## Next Steps

- [Service Registry](service-registry.md) - Plugin-to-plugin communication
- [Interceptors](interceptors.md) - Add retry, circuit breaker, auth
- [Configuration Reference](../reference/configuration.md) - All config options
