package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "0.1.0"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()

	if *showVersion {
		fmt.Printf("protoc-gen-connect-plugin %v\n", version)
		return
	}

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	// Generate one plugin file per service
	for _, service := range file.Services {
		generatePlugin(gen, file, service)
		generateDelegate(gen, file, service)
	}
}

func generatePlugin(gen *protogen.Plugin, file *protogen.File, service *protogen.Service) {
	// Output to a plugin subpackage to avoid import cycles
	// e.g., examples/kv/gen/kvv1plugin/plugin.go
	pluginPkgName := string(file.GoPackageName) + "plugin"
	pluginPkgPath := protogen.GoImportPath(string(file.GoImportPath) + "/" + pluginPkgName)

	filename := pluginPkgName + "/plugin.go"
	g := gen.NewGeneratedFile(filename, pluginPkgPath)

	// Package declaration
	g.P("// Code generated by protoc-gen-connect-plugin. DO NOT EDIT.")
	g.P()
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", pluginPkgName)
	g.P()

	// Compute import paths
	// Connect package: github.com/masegraye/connect-plugin-go/examples/kv/gen/kvv1connect
	connectPkgPath := string(file.GoImportPath) + "/" + string(file.GoPackageName) + "connect"

	// Write imports
	g.P("import (")
	g.P(`	"fmt"`)
	g.P(`	"net/http"`)
	g.P()
	g.P(`	"connectrpc.com/connect"`)
	g.P(`	connectplugin "github.com/masegraye/connect-plugin-go"`)
	g.P(`	`, file.GoPackageName, `connect "`, connectPkgPath, `"`)
	g.P(")")
	g.P()

	// Generate plugin struct
	pluginName := service.GoName + "Plugin"
	handlerName := service.GoName + "Handler"

	g.P("// ", pluginName, " implements connectplugin.Plugin for ", service.GoName, ".")
	g.P("type ", pluginName, " struct{}")
	g.P()

	g.P("var _ connectplugin.Plugin = (*", pluginName, ")(nil)")
	g.P()

	// Generate Metadata()
	// Default plugin name is lowercase service name without "Service" suffix
	// KVService -> kv, AuthService -> auth
	pluginDefaultName := strings.ToLower(strings.TrimSuffix(service.GoName, "Service"))

	serviceName := string(file.GoPackageName) + "connect." + service.GoName + "Name"
	g.P("// Metadata returns plugin metadata.")
	g.P("func (p *", pluginName, ") Metadata() connectplugin.PluginMetadata {")
	g.P("	return connectplugin.PluginMetadata{")
	g.P(`		Name:    "`, pluginDefaultName, `",`)
	g.P("		Path:    ", serviceName, ",")
	g.P(`		Version: "1.0.0",`)
	g.P("		Provides: []connectplugin.ServiceDeclaration{")
	g.P("			{")
	g.P(`				Type:    "`, pluginDefaultName, `",`)
	g.P(`				Version: "1.0.0",`)
	g.P("				Path:    ", serviceName, ",")
	g.P("			},")
	g.P("		},")
	g.P("	}")
	g.P("}")
	g.P()

	// Generate ConnectServer()
	g.P("// ConnectServer creates a server-side handler for this plugin.")
	g.P("func (p *", pluginName, ") ConnectServer(impl any) (string, http.Handler, error) {")
	g.P("	handler, ok := impl.(", file.GoPackageName, "connect.", handlerName, ")")
	g.P("	if !ok {")
	g.P(`		return "", nil, fmt.Errorf("impl must implement `, handlerName, `, got %T", impl)`)
	g.P("	}")
	g.P()
	g.P("	path, h := ", file.GoPackageName, "connect.New", service.GoName, "Handler(handler)")
	g.P("	return path, h, nil")
	g.P("}")
	g.P()

	// Generate ConnectClient()
	g.P("// ConnectClient creates a client-side plugin instance.")
	g.P("func (p *", pluginName, ") ConnectClient(baseURL string, httpClient connect.HTTPClient) (any, error) {")
	g.P("	return ", file.GoPackageName, "connect.New", service.GoName, "Client(httpClient, baseURL), nil")
	g.P("}")
	g.P()
}

// generateDelegate generates the delegate package with clean Go interfaces.
func generateDelegate(gen *protogen.Plugin, file *protogen.File, service *protogen.Service) {
	// Output to a delegate subpackage
	// e.g., examples/kv/gen/kvv1delegate/delegate.go
	delegatePkgName := string(file.GoPackageName) + "delegate"
	delegatePkgPath := protogen.GoImportPath(string(file.GoImportPath) + "/" + delegatePkgName)

	filename := delegatePkgName + "/delegate.go"
	g := gen.NewGeneratedFile(filename, delegatePkgPath)

	// Package declaration
	g.P("// Code generated by protoc-gen-connect-plugin. DO NOT EDIT.")
	g.P()
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", delegatePkgName)
	g.P()

	// Compute import paths
	connectPkgPath := string(file.GoImportPath) + "/" + string(file.GoPackageName) + "connect"
	msgPkgPath := string(file.GoImportPath)

	// Check if we have streaming methods
	hasStreaming := false
	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			hasStreaming = true
			break
		}
	}

	// Write imports
	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"net/http"`)
	g.P()
	g.P(`	"connectrpc.com/connect"`)
	g.P(`	`, file.GoPackageName, ` "`, msgPkgPath, `"`)
	g.P(`	`, file.GoPackageName, `connect "`, connectPkgPath, `"`)
	g.P(")")
	g.P()

	// Silence unused import warnings if no streaming
	if !hasStreaming {
		g.P("// Ensure imports are used")
		g.P("var _ = connect.IsAtLeastVersion1_13_0")
		g.P()
	}

	// Interface name: KVService -> KVStore, AuthService -> Auth, LoggerService -> Logger
	interfaceName := strings.TrimSuffix(service.GoName, "Service")
	if interfaceName == service.GoName {
		// No "Service" suffix, just use as-is
		interfaceName = service.GoName
	}
	// Special case: if it ends in just the name, add "Store" or similar
	// Actually, let's keep it simple: KVService -> KV, AuthService -> Auth
	// User can alias import if they want different names

	delegateStructName := strings.ToLower(interfaceName[:1]) + interfaceName[1:] + "Delegate"
	clientType := string(file.GoPackageName) + "connect." + service.GoName + "Client"

	// Generate interface
	g.P("// ", interfaceName, " is the domain interface for ", service.GoName, ".")
	g.P("type ", interfaceName, " interface {")
	for _, method := range service.Methods {
		generateInterfaceMethod(g, file, method)
	}
	g.P("}")
	g.P()

	// Generate delegate struct
	g.P("// ", delegateStructName, " implements ", interfaceName, " using a Connect client.")
	g.P("type ", delegateStructName, " struct {")
	g.P("	client ", clientType)
	g.P("}")
	g.P()

	// Compile-time interface check
	g.P("var _ ", interfaceName, " = (*", delegateStructName, ")(nil)")
	g.P()

	// Generate New constructor (from client)
	g.P("// New creates a ", interfaceName, " from an existing Connect client.")
	g.P("func New(client ", clientType, ") ", interfaceName, " {")
	g.P("	return &", delegateStructName, "{client: client}")
	g.P("}")
	g.P()

	// Generate NewFromURL constructor
	g.P("// NewFromURL creates a ", interfaceName, " from a URL.")
	g.P("func NewFromURL(url string, opts ...connect.ClientOption) ", interfaceName, " {")
	g.P("	client := ", file.GoPackageName, "connect.New", service.GoName, "Client(http.DefaultClient, url, opts...)")
	g.P("	return &", delegateStructName, "{client: client}")
	g.P("}")
	g.P()

	// Generate method implementations
	for _, method := range service.Methods {
		generateDelegateMethod(g, file, method, delegateStructName)
	}
}

// generateInterfaceMethod generates a single method signature for the interface.
func generateInterfaceMethod(g *protogen.GeneratedFile, file *protogen.File, method *protogen.Method) {
	// Get method info
	isServerStreaming := method.Desc.IsStreamingServer()
	isClientStreaming := method.Desc.IsStreamingClient()

	// Generate comment from proto comment
	if method.Comments.Leading != "" {
		comment := strings.TrimSpace(string(method.Comments.Leading))
		for _, line := range strings.Split(comment, "\n") {
			g.P("	// ", strings.TrimPrefix(line, "// "))
		}
	}

	// Build signature
	if isServerStreaming || isClientStreaming {
		// Streaming: simplified input, pass-through stream output
		generateStreamingInterfaceMethod(g, file, method)
	} else {
		// Unary: flatten request/response
		generateUnaryInterfaceMethod(g, file, method)
	}
}

// generateUnaryInterfaceMethod generates a flattened unary method signature.
func generateUnaryInterfaceMethod(g *protogen.GeneratedFile, file *protogen.File, method *protogen.Method) {
	// Build parameter list from input message fields
	params := []string{"ctx context.Context"}
	for _, field := range method.Input.Fields {
		goType := protoFieldToGoType(file, field)
		params = append(params, lowerFirst(field.GoName)+" "+goType)
	}

	// Build return signature
	var returnSig string
	if len(method.Output.Fields) > 0 {
		returns := []string{}
		for _, field := range method.Output.Fields {
			goType := protoFieldToGoType(file, field)
			returns = append(returns, lowerFirst(field.GoName)+" "+goType)
		}
		returns = append(returns, "err error")
		returnSig = "(" + strings.Join(returns, ", ") + ")"
	} else {
		returnSig = "error"
	}

	g.P("	", method.GoName, "(", strings.Join(params, ", "), ") ", returnSig)
}

// generateStreamingInterfaceMethod generates a streaming method signature.
func generateStreamingInterfaceMethod(g *protogen.GeneratedFile, file *protogen.File, method *protogen.Method) {
	// Simplified input parameters
	params := []string{"ctx context.Context"}
	for _, field := range method.Input.Fields {
		goType := protoFieldToGoType(file, field)
		params = append(params, lowerFirst(field.GoName)+" "+goType)
	}

	// Return the stream type
	msgPkg := string(file.GoPackageName)
	outputType := msgPkg + "." + method.Output.GoIdent.GoName

	if method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
		// Server streaming: returns ServerStreamForClient
		g.P("	", method.GoName, "(", strings.Join(params, ", "), ") (*connect.ServerStreamForClient[", outputType, "], error)")
	} else if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		// Client streaming: returns ClientStreamForClient
		g.P("	", method.GoName, "(ctx context.Context) (*connect.ClientStreamForClient[", msgPkg, ".", method.Input.GoIdent.GoName, ", ", outputType, "], error)")
	} else {
		// Bidirectional streaming
		g.P("	", method.GoName, "(ctx context.Context) (*connect.BidiStreamForClient[", msgPkg, ".", method.Input.GoIdent.GoName, ", ", outputType, "], error)")
	}
}

// generateDelegateMethod generates a method implementation for the delegate.
func generateDelegateMethod(g *protogen.GeneratedFile, file *protogen.File, method *protogen.Method, delegateStructName string) {
	isServerStreaming := method.Desc.IsStreamingServer()
	isClientStreaming := method.Desc.IsStreamingClient()

	if isServerStreaming || isClientStreaming {
		generateStreamingDelegateMethod(g, file, method, delegateStructName)
	} else {
		generateUnaryDelegateMethod(g, file, method, delegateStructName)
	}
}

// generateUnaryDelegateMethod generates a flattened unary method implementation.
func generateUnaryDelegateMethod(g *protogen.GeneratedFile, file *protogen.File, method *protogen.Method, delegateStructName string) {
	msgPkg := string(file.GoPackageName)
	hasOutputFields := len(method.Output.Fields) > 0

	// Build parameter list
	params := []string{"ctx context.Context"}
	for _, field := range method.Input.Fields {
		goType := protoFieldToGoType(file, field)
		params = append(params, lowerFirst(field.GoName)+" "+goType)
	}

	// Build return signature
	var returnSig string
	if hasOutputFields {
		returns := []string{}
		for _, field := range method.Output.Fields {
			goType := protoFieldToGoType(file, field)
			returns = append(returns, lowerFirst(field.GoName)+" "+goType)
		}
		returns = append(returns, "err error")
		returnSig = "(" + strings.Join(returns, ", ") + ")"
	} else {
		returnSig = "error"
	}

	// Method signature
	g.P("// ", method.GoName, " implements ", method.GoName, " via Connect client.")
	g.P("func (d *", delegateStructName, ") ", method.GoName, "(", strings.Join(params, ", "), ") ", returnSig, " {")

	// Build request
	g.P("	req := &", msgPkg, ".", method.Input.GoIdent.GoName, "{")
	for _, field := range method.Input.Fields {
		g.P("		", field.GoName, ": ", lowerFirst(field.GoName), ",")
	}
	g.P("	}")
	g.P()

	// Make call - use _ for resp if no output fields
	if hasOutputFields {
		g.P("	resp, err := d.client.", method.GoName, "(ctx, connect.NewRequest(req))")
	} else {
		g.P("	_, err := d.client.", method.GoName, "(ctx, connect.NewRequest(req))")
	}
	g.P("	if err != nil {")

	// Return zero values for all fields plus error
	if hasOutputFields {
		zeroReturns := make([]string, len(method.Output.Fields))
		for i, field := range method.Output.Fields {
			zeroReturns[i] = zeroValue(field)
		}
		zeroReturns = append(zeroReturns, "err")
		g.P("		return ", strings.Join(zeroReturns, ", "))
	} else {
		g.P("		return err")
	}
	g.P("	}")
	g.P()

	// Return response fields
	if hasOutputFields {
		returnExprs := make([]string, len(method.Output.Fields))
		for i, field := range method.Output.Fields {
			returnExprs[i] = "resp.Msg." + field.GoName
		}
		returnExprs = append(returnExprs, "nil")
		g.P("	return ", strings.Join(returnExprs, ", "))
	} else {
		g.P("	return nil")
	}
	g.P("}")
	g.P()
}

// generateStreamingDelegateMethod generates a streaming method implementation.
func generateStreamingDelegateMethod(g *protogen.GeneratedFile, file *protogen.File, method *protogen.Method, delegateStructName string) {
	msgPkg := string(file.GoPackageName)
	outputType := msgPkg + "." + method.Output.GoIdent.GoName

	if method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
		// Server streaming
		params := []string{"ctx context.Context"}
		for _, field := range method.Input.Fields {
			goType := protoFieldToGoType(file, field)
			params = append(params, lowerFirst(field.GoName)+" "+goType)
		}

		g.P("// ", method.GoName, " implements ", method.GoName, " via Connect client.")
		g.P("func (d *", delegateStructName, ") ", method.GoName, "(", strings.Join(params, ", "), ") (*connect.ServerStreamForClient[", outputType, "], error) {")

		// Build request
		g.P("	req := &", msgPkg, ".", method.Input.GoIdent.GoName, "{")
		for _, field := range method.Input.Fields {
			g.P("		", field.GoName, ": ", lowerFirst(field.GoName), ",")
		}
		g.P("	}")
		g.P()
		g.P("	return d.client.", method.GoName, "(ctx, connect.NewRequest(req))")
		g.P("}")
		g.P()
	} else if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		// Client streaming
		inputType := msgPkg + "." + method.Input.GoIdent.GoName

		g.P("// ", method.GoName, " implements ", method.GoName, " via Connect client.")
		g.P("func (d *", delegateStructName, ") ", method.GoName, "(ctx context.Context) (*connect.ClientStreamForClient[", inputType, ", ", outputType, "], error) {")
		g.P("	return d.client.", method.GoName, "(ctx), nil")
		g.P("}")
		g.P()
	} else {
		// Bidirectional streaming
		inputType := msgPkg + "." + method.Input.GoIdent.GoName

		g.P("// ", method.GoName, " implements ", method.GoName, " via Connect client.")
		g.P("func (d *", delegateStructName, ") ", method.GoName, "(ctx context.Context) (*connect.BidiStreamForClient[", inputType, ", ", outputType, "], error) {")
		g.P("	return d.client.", method.GoName, "(ctx), nil")
		g.P("}")
		g.P()
	}
}

// protoFieldToGoType converts a proto field to its Go type string.
func protoFieldToGoType(file *protogen.File, field *protogen.Field) string {
	// Handle repeated fields
	if field.Desc.IsList() {
		elemType := scalarToGoType(field)
		if elemType != "" {
			return "[]" + elemType
		}
		// Message type
		return "[]*" + string(file.GoPackageName) + "." + field.Message.GoIdent.GoName
	}

	// Handle map fields
	if field.Desc.IsMap() {
		keyField := field.Message.Fields[0]
		valueField := field.Message.Fields[1]
		keyType := scalarToGoType(keyField)
		valueType := scalarToGoType(valueField)
		if valueType == "" {
			valueType = "*" + string(file.GoPackageName) + "." + valueField.Message.GoIdent.GoName
		}
		return "map[" + keyType + "]" + valueType
	}

	// Scalar types
	goType := scalarToGoType(field)
	if goType != "" {
		return goType
	}

	// Message type
	if field.Message != nil {
		return "*" + string(file.GoPackageName) + "." + field.Message.GoIdent.GoName
	}

	// Enum type
	if field.Enum != nil {
		return string(file.GoPackageName) + "." + field.Enum.GoIdent.GoName
	}

	return "any"
}

// scalarToGoType returns the Go type for scalar proto types.
func scalarToGoType(field *protogen.Field) string {
	switch field.Desc.Kind().String() {
	case "double":
		return "float64"
	case "float":
		return "float32"
	case "int64", "sfixed64", "sint64":
		return "int64"
	case "uint64", "fixed64":
		return "uint64"
	case "int32", "sfixed32", "sint32":
		return "int32"
	case "uint32", "fixed32":
		return "uint32"
	case "bool":
		return "bool"
	case "string":
		return "string"
	case "bytes":
		return "[]byte"
	default:
		return ""
	}
}

// zeroValue returns the zero value for a proto field.
func zeroValue(field *protogen.Field) string {
	if field.Desc.IsList() || field.Desc.IsMap() || field.Message != nil {
		return "nil"
	}
	switch field.Desc.Kind().String() {
	case "double", "float":
		return "0"
	case "int64", "sfixed64", "sint64", "uint64", "fixed64", "int32", "sfixed32", "sint32", "uint32", "fixed32":
		return "0"
	case "bool":
		return "false"
	case "string":
		return `""`
	case "bytes":
		return "nil"
	default:
		if field.Enum != nil {
			return "0"
		}
		return "nil"
	}
}

// lowerFirst returns the string with the first character lowercased.
func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}
