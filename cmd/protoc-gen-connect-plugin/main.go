package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "0.1.0"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()

	if *showVersion {
		fmt.Printf("protoc-gen-connect-plugin %v\n", version)
		return
	}

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	// Generate one plugin file per service
	for _, service := range file.Services {
		generatePlugin(gen, file, service)
	}
}

func generatePlugin(gen *protogen.Plugin, file *protogen.File, service *protogen.Service) {
	// Output to a plugin subpackage to avoid import cycles
	// e.g., examples/kv/gen/kvv1plugin/plugin.go
	pluginPkgName := string(file.GoPackageName) + "plugin"
	pluginPkgPath := protogen.GoImportPath(string(file.GoImportPath) + "/" + pluginPkgName)

	filename := pluginPkgName + "/plugin.go"
	g := gen.NewGeneratedFile(filename, pluginPkgPath)

	// Package declaration
	g.P("// Code generated by protoc-gen-connect-plugin. DO NOT EDIT.")
	g.P()
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", pluginPkgName)
	g.P()

	// Compute import paths
	// Connect package: github.com/masegraye/connect-plugin-go/examples/kv/gen/kvv1connect
	connectPkgPath := string(file.GoImportPath) + "/" + string(file.GoPackageName) + "connect"

	// Write imports
	g.P("import (")
	g.P(`	"fmt"`)
	g.P(`	"net/http"`)
	g.P()
	g.P(`	"connectrpc.com/connect"`)
	g.P(`	connectplugin "github.com/masegraye/connect-plugin-go"`)
	g.P(`	`, file.GoPackageName, `connect "`, connectPkgPath, `"`)
	g.P(")")
	g.P()

	// Generate plugin struct
	pluginName := service.GoName + "Plugin"
	handlerName := service.GoName + "Handler"

	g.P("// ", pluginName, " implements connectplugin.Plugin for ", service.GoName, ".")
	g.P("type ", pluginName, " struct{}")
	g.P()

	g.P("var _ connectplugin.Plugin = (*", pluginName, ")(nil)")
	g.P()

	// Generate Metadata()
	// Default plugin name is lowercase service name without "Service" suffix
	// KVService -> kv, AuthService -> auth
	pluginDefaultName := strings.ToLower(strings.TrimSuffix(service.GoName, "Service"))

	serviceName := string(file.GoPackageName) + "connect." + service.GoName + "Name"
	g.P("// Metadata returns plugin metadata.")
	g.P("func (p *", pluginName, ") Metadata() connectplugin.PluginMetadata {")
	g.P("	return connectplugin.PluginMetadata{")
	g.P(`		Name:    "`, pluginDefaultName, `",`)
	g.P("		Path:    ", serviceName, ",")
	g.P(`		Version: "1.0.0",`)
	g.P("	}")
	g.P("}")
	g.P()

	// Generate ConnectServer()
	g.P("// ConnectServer creates a server-side handler for this plugin.")
	g.P("func (p *", pluginName, ") ConnectServer(impl any) (string, http.Handler, error) {")
	g.P("	handler, ok := impl.(", file.GoPackageName, "connect.", handlerName, ")")
	g.P("	if !ok {")
	g.P(`		return "", nil, fmt.Errorf("impl must implement `, handlerName, `, got %T", impl)`)
	g.P("	}")
	g.P()
	g.P("	path, h := ", file.GoPackageName, "connect.New", service.GoName, "Handler(handler)")
	g.P("	return path, h, nil")
	g.P("}")
	g.P()

	// Generate ConnectClient()
	g.P("// ConnectClient creates a client-side plugin instance.")
	g.P("func (p *", pluginName, ") ConnectClient(baseURL string, httpClient connect.HTTPClient) (any, error) {")
	g.P("	return ", file.GoPackageName, "connect.New", service.GoName, "Client(httpClient, baseURL), nil")
	g.P("}")
	g.P()
}
