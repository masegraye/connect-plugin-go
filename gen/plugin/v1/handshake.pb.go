// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.0
// source: plugin/v1/handshake.proto

package connectpluginv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type HandshakeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Core protocol version the client supports.
	// Currently must be 1.
	CoreProtocolVersion int32 `protobuf:"varint,1,opt,name=core_protocol_version,json=coreProtocolVersion,proto3" json:"core_protocol_version,omitempty"`
	// App protocol version the client supports.
	// v1 uses simple exact match - no negotiation of multiple versions.
	AppProtocolVersion int32 `protobuf:"varint,2,opt,name=app_protocol_version,json=appProtocolVersion,proto3" json:"app_protocol_version,omitempty"`
	// Magic cookie for basic validation (not security).
	// Must match server's expected value.
	MagicCookieKey   string `protobuf:"bytes,3,opt,name=magic_cookie_key,json=magicCookieKey,proto3" json:"magic_cookie_key,omitempty"`
	MagicCookieValue string `protobuf:"bytes,4,opt,name=magic_cookie_value,json=magicCookieValue,proto3" json:"magic_cookie_value,omitempty"`
	// Plugins the client wants to use.
	// Server validates these are available.
	RequestedPlugins []string `protobuf:"bytes,5,rep,name=requested_plugins,json=requestedPlugins,proto3" json:"requested_plugins,omitempty"`
	// Client metadata (for debugging/logging).
	ClientMetadata map[string]string `protobuf:"bytes,6,rep,name=client_metadata,json=clientMetadata,proto3" json:"client_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// NEW Phase 2: Plugin's self-declared identity.
	// This is the plugin's notion of its own name (e.g., "cache-plugin").
	SelfId string `protobuf:"bytes,10,opt,name=self_id,json=selfId,proto3" json:"self_id,omitempty"`
	// NEW Phase 2: Plugin's self-declared version.
	SelfVersion   string `protobuf:"bytes,11,opt,name=self_version,json=selfVersion,proto3" json:"self_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeRequest) Reset() {
	*x = HandshakeRequest{}
	mi := &file_plugin_v1_handshake_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeRequest) ProtoMessage() {}

func (x *HandshakeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_plugin_v1_handshake_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeRequest.ProtoReflect.Descriptor instead.
func (*HandshakeRequest) Descriptor() ([]byte, []int) {
	return file_plugin_v1_handshake_proto_rawDescGZIP(), []int{0}
}

func (x *HandshakeRequest) GetCoreProtocolVersion() int32 {
	if x != nil {
		return x.CoreProtocolVersion
	}
	return 0
}

func (x *HandshakeRequest) GetAppProtocolVersion() int32 {
	if x != nil {
		return x.AppProtocolVersion
	}
	return 0
}

func (x *HandshakeRequest) GetMagicCookieKey() string {
	if x != nil {
		return x.MagicCookieKey
	}
	return ""
}

func (x *HandshakeRequest) GetMagicCookieValue() string {
	if x != nil {
		return x.MagicCookieValue
	}
	return ""
}

func (x *HandshakeRequest) GetRequestedPlugins() []string {
	if x != nil {
		return x.RequestedPlugins
	}
	return nil
}

func (x *HandshakeRequest) GetClientMetadata() map[string]string {
	if x != nil {
		return x.ClientMetadata
	}
	return nil
}

func (x *HandshakeRequest) GetSelfId() string {
	if x != nil {
		return x.SelfId
	}
	return ""
}

func (x *HandshakeRequest) GetSelfVersion() string {
	if x != nil {
		return x.SelfVersion
	}
	return ""
}

type HandshakeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Negotiated core protocol version (always 1 for v1).
	CoreProtocolVersion int32 `protobuf:"varint,1,opt,name=core_protocol_version,json=coreProtocolVersion,proto3" json:"core_protocol_version,omitempty"`
	// Negotiated app protocol version (must match request for v1).
	AppProtocolVersion int32 `protobuf:"varint,2,opt,name=app_protocol_version,json=appProtocolVersion,proto3" json:"app_protocol_version,omitempty"`
	// Available plugins on this server.
	Plugins []*PluginInfo `protobuf:"bytes,3,rep,name=plugins,proto3" json:"plugins,omitempty"`
	// Server metadata (version, etc).
	ServerMetadata map[string]string `protobuf:"bytes,4,rep,name=server_metadata,json=serverMetadata,proto3" json:"server_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Host capabilities available to plugins.
	HostCapabilities []*Capability `protobuf:"bytes,5,rep,name=host_capabilities,json=hostCapabilities,proto3" json:"host_capabilities,omitempty"`
	// NEW Phase 2: Host-assigned runtime identity.
	// This is globally unique and opaque to the plugin.
	RuntimeId string `protobuf:"bytes,10,opt,name=runtime_id,json=runtimeId,proto3" json:"runtime_id,omitempty"`
	// NEW Phase 2: Token for authenticating calls to host.
	// Plugin includes this in Authorization header for all host API calls.
	RuntimeToken  string `protobuf:"bytes,11,opt,name=runtime_token,json=runtimeToken,proto3" json:"runtime_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeResponse) Reset() {
	*x = HandshakeResponse{}
	mi := &file_plugin_v1_handshake_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeResponse) ProtoMessage() {}

func (x *HandshakeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_plugin_v1_handshake_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeResponse.ProtoReflect.Descriptor instead.
func (*HandshakeResponse) Descriptor() ([]byte, []int) {
	return file_plugin_v1_handshake_proto_rawDescGZIP(), []int{1}
}

func (x *HandshakeResponse) GetCoreProtocolVersion() int32 {
	if x != nil {
		return x.CoreProtocolVersion
	}
	return 0
}

func (x *HandshakeResponse) GetAppProtocolVersion() int32 {
	if x != nil {
		return x.AppProtocolVersion
	}
	return 0
}

func (x *HandshakeResponse) GetPlugins() []*PluginInfo {
	if x != nil {
		return x.Plugins
	}
	return nil
}

func (x *HandshakeResponse) GetServerMetadata() map[string]string {
	if x != nil {
		return x.ServerMetadata
	}
	return nil
}

func (x *HandshakeResponse) GetHostCapabilities() []*Capability {
	if x != nil {
		return x.HostCapabilities
	}
	return nil
}

func (x *HandshakeResponse) GetRuntimeId() string {
	if x != nil {
		return x.RuntimeId
	}
	return ""
}

func (x *HandshakeResponse) GetRuntimeToken() string {
	if x != nil {
		return x.RuntimeToken
	}
	return ""
}

type PluginInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Plugin name (e.g., "kv", "auth").
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Plugin version (semantic version string).
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Service path this plugin is served at.
	ServicePath string `protobuf:"bytes,3,opt,name=service_path,json=servicePath,proto3" json:"service_path,omitempty"`
	// NEW Phase 2: Services this plugin provides.
	Provides []*ServiceDeclaration `protobuf:"bytes,10,rep,name=provides,proto3" json:"provides,omitempty"`
	// NEW Phase 2: Services this plugin requires.
	Requires      []*ServiceDependency `protobuf:"bytes,11,rep,name=requires,proto3" json:"requires,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginInfo) Reset() {
	*x = PluginInfo{}
	mi := &file_plugin_v1_handshake_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginInfo) ProtoMessage() {}

func (x *PluginInfo) ProtoReflect() protoreflect.Message {
	mi := &file_plugin_v1_handshake_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginInfo.ProtoReflect.Descriptor instead.
func (*PluginInfo) Descriptor() ([]byte, []int) {
	return file_plugin_v1_handshake_proto_rawDescGZIP(), []int{2}
}

func (x *PluginInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PluginInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *PluginInfo) GetServicePath() string {
	if x != nil {
		return x.ServicePath
	}
	return ""
}

func (x *PluginInfo) GetProvides() []*ServiceDeclaration {
	if x != nil {
		return x.Provides
	}
	return nil
}

func (x *PluginInfo) GetRequires() []*ServiceDependency {
	if x != nil {
		return x.Requires
	}
	return nil
}

type Capability struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Capability type (e.g., "logger", "metrics", "secrets").
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Capability version (semver).
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Endpoint URL for requesting this capability.
	Endpoint      string `protobuf:"bytes,3,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Capability) Reset() {
	*x = Capability{}
	mi := &file_plugin_v1_handshake_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Capability) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Capability) ProtoMessage() {}

func (x *Capability) ProtoReflect() protoreflect.Message {
	mi := &file_plugin_v1_handshake_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Capability.ProtoReflect.Descriptor instead.
func (*Capability) Descriptor() ([]byte, []int) {
	return file_plugin_v1_handshake_proto_rawDescGZIP(), []int{3}
}

func (x *Capability) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *Capability) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Capability) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

// NEW Phase 2: Service declaration (what a plugin provides).
type ServiceDeclaration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Service type (e.g., "logger", "cache", "metrics").
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Service version (semver).
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Service endpoint path (relative to plugin base URL).
	// e.g., "/logger.v1.Logger/"
	Path          string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServiceDeclaration) Reset() {
	*x = ServiceDeclaration{}
	mi := &file_plugin_v1_handshake_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceDeclaration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceDeclaration) ProtoMessage() {}

func (x *ServiceDeclaration) ProtoReflect() protoreflect.Message {
	mi := &file_plugin_v1_handshake_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceDeclaration.ProtoReflect.Descriptor instead.
func (*ServiceDeclaration) Descriptor() ([]byte, []int) {
	return file_plugin_v1_handshake_proto_rawDescGZIP(), []int{4}
}

func (x *ServiceDeclaration) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ServiceDeclaration) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ServiceDeclaration) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

// NEW Phase 2: Service dependency (what a plugin requires).
type ServiceDependency struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Service type required (e.g., "logger", "cache").
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Minimum version required (semver).
	MinVersion string `protobuf:"bytes,2,opt,name=min_version,json=minVersion,proto3" json:"min_version,omitempty"`
	// Block startup if this service is unavailable?
	RequiredForStartup bool `protobuf:"varint,3,opt,name=required_for_startup,json=requiredForStartup,proto3" json:"required_for_startup,omitempty"`
	// Should host send WatchService events for this dependency?
	WatchForChanges bool `protobuf:"varint,4,opt,name=watch_for_changes,json=watchForChanges,proto3" json:"watch_for_changes,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ServiceDependency) Reset() {
	*x = ServiceDependency{}
	mi := &file_plugin_v1_handshake_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceDependency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceDependency) ProtoMessage() {}

func (x *ServiceDependency) ProtoReflect() protoreflect.Message {
	mi := &file_plugin_v1_handshake_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceDependency.ProtoReflect.Descriptor instead.
func (*ServiceDependency) Descriptor() ([]byte, []int) {
	return file_plugin_v1_handshake_proto_rawDescGZIP(), []int{5}
}

func (x *ServiceDependency) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ServiceDependency) GetMinVersion() string {
	if x != nil {
		return x.MinVersion
	}
	return ""
}

func (x *ServiceDependency) GetRequiredForStartup() bool {
	if x != nil {
		return x.RequiredForStartup
	}
	return false
}

func (x *ServiceDependency) GetWatchForChanges() bool {
	if x != nil {
		return x.WatchForChanges
	}
	return false
}

var File_plugin_v1_handshake_proto protoreflect.FileDescriptor

const file_plugin_v1_handshake_proto_rawDesc = "" +
	"\n" +
	"\x19plugin/v1/handshake.proto\x12\x10connectplugin.v1\"\xdd\x03\n" +
	"\x10HandshakeRequest\x122\n" +
	"\x15core_protocol_version\x18\x01 \x01(\x05R\x13coreProtocolVersion\x120\n" +
	"\x14app_protocol_version\x18\x02 \x01(\x05R\x12appProtocolVersion\x12(\n" +
	"\x10magic_cookie_key\x18\x03 \x01(\tR\x0emagicCookieKey\x12,\n" +
	"\x12magic_cookie_value\x18\x04 \x01(\tR\x10magicCookieValue\x12+\n" +
	"\x11requested_plugins\x18\x05 \x03(\tR\x10requestedPlugins\x12_\n" +
	"\x0fclient_metadata\x18\x06 \x03(\v26.connectplugin.v1.HandshakeRequest.ClientMetadataEntryR\x0eclientMetadata\x12\x17\n" +
	"\aself_id\x18\n" +
	" \x01(\tR\x06selfId\x12!\n" +
	"\fself_version\x18\v \x01(\tR\vselfVersion\x1aA\n" +
	"\x13ClientMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe5\x03\n" +
	"\x11HandshakeResponse\x122\n" +
	"\x15core_protocol_version\x18\x01 \x01(\x05R\x13coreProtocolVersion\x120\n" +
	"\x14app_protocol_version\x18\x02 \x01(\x05R\x12appProtocolVersion\x126\n" +
	"\aplugins\x18\x03 \x03(\v2\x1c.connectplugin.v1.PluginInfoR\aplugins\x12`\n" +
	"\x0fserver_metadata\x18\x04 \x03(\v27.connectplugin.v1.HandshakeResponse.ServerMetadataEntryR\x0eserverMetadata\x12I\n" +
	"\x11host_capabilities\x18\x05 \x03(\v2\x1c.connectplugin.v1.CapabilityR\x10hostCapabilities\x12\x1d\n" +
	"\n" +
	"runtime_id\x18\n" +
	" \x01(\tR\truntimeId\x12#\n" +
	"\rruntime_token\x18\v \x01(\tR\fruntimeToken\x1aA\n" +
	"\x13ServerMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe0\x01\n" +
	"\n" +
	"PluginInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12!\n" +
	"\fservice_path\x18\x03 \x01(\tR\vservicePath\x12@\n" +
	"\bprovides\x18\n" +
	" \x03(\v2$.connectplugin.v1.ServiceDeclarationR\bprovides\x12?\n" +
	"\brequires\x18\v \x03(\v2#.connectplugin.v1.ServiceDependencyR\brequires\"V\n" +
	"\n" +
	"Capability\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x1a\n" +
	"\bendpoint\x18\x03 \x01(\tR\bendpoint\"V\n" +
	"\x12ServiceDeclaration\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\"\xa6\x01\n" +
	"\x11ServiceDependency\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x1f\n" +
	"\vmin_version\x18\x02 \x01(\tR\n" +
	"minVersion\x120\n" +
	"\x14required_for_startup\x18\x03 \x01(\bR\x12requiredForStartup\x12*\n" +
	"\x11watch_for_changes\x18\x04 \x01(\bR\x0fwatchForChanges2h\n" +
	"\x10HandshakeService\x12T\n" +
	"\tHandshake\x12\".connectplugin.v1.HandshakeRequest\x1a#.connectplugin.v1.HandshakeResponseBFZDgithub.com/masegraye/connect-plugin-go/gen/plugin/v1;connectpluginv1b\x06proto3"

var (
	file_plugin_v1_handshake_proto_rawDescOnce sync.Once
	file_plugin_v1_handshake_proto_rawDescData []byte
)

func file_plugin_v1_handshake_proto_rawDescGZIP() []byte {
	file_plugin_v1_handshake_proto_rawDescOnce.Do(func() {
		file_plugin_v1_handshake_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_plugin_v1_handshake_proto_rawDesc), len(file_plugin_v1_handshake_proto_rawDesc)))
	})
	return file_plugin_v1_handshake_proto_rawDescData
}

var file_plugin_v1_handshake_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_plugin_v1_handshake_proto_goTypes = []any{
	(*HandshakeRequest)(nil),   // 0: connectplugin.v1.HandshakeRequest
	(*HandshakeResponse)(nil),  // 1: connectplugin.v1.HandshakeResponse
	(*PluginInfo)(nil),         // 2: connectplugin.v1.PluginInfo
	(*Capability)(nil),         // 3: connectplugin.v1.Capability
	(*ServiceDeclaration)(nil), // 4: connectplugin.v1.ServiceDeclaration
	(*ServiceDependency)(nil),  // 5: connectplugin.v1.ServiceDependency
	nil,                        // 6: connectplugin.v1.HandshakeRequest.ClientMetadataEntry
	nil,                        // 7: connectplugin.v1.HandshakeResponse.ServerMetadataEntry
}
var file_plugin_v1_handshake_proto_depIdxs = []int32{
	6, // 0: connectplugin.v1.HandshakeRequest.client_metadata:type_name -> connectplugin.v1.HandshakeRequest.ClientMetadataEntry
	2, // 1: connectplugin.v1.HandshakeResponse.plugins:type_name -> connectplugin.v1.PluginInfo
	7, // 2: connectplugin.v1.HandshakeResponse.server_metadata:type_name -> connectplugin.v1.HandshakeResponse.ServerMetadataEntry
	3, // 3: connectplugin.v1.HandshakeResponse.host_capabilities:type_name -> connectplugin.v1.Capability
	4, // 4: connectplugin.v1.PluginInfo.provides:type_name -> connectplugin.v1.ServiceDeclaration
	5, // 5: connectplugin.v1.PluginInfo.requires:type_name -> connectplugin.v1.ServiceDependency
	0, // 6: connectplugin.v1.HandshakeService.Handshake:input_type -> connectplugin.v1.HandshakeRequest
	1, // 7: connectplugin.v1.HandshakeService.Handshake:output_type -> connectplugin.v1.HandshakeResponse
	7, // [7:8] is the sub-list for method output_type
	6, // [6:7] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { file_plugin_v1_handshake_proto_init() }
func file_plugin_v1_handshake_proto_init() {
	if File_plugin_v1_handshake_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_plugin_v1_handshake_proto_rawDesc), len(file_plugin_v1_handshake_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_plugin_v1_handshake_proto_goTypes,
		DependencyIndexes: file_plugin_v1_handshake_proto_depIdxs,
		MessageInfos:      file_plugin_v1_handshake_proto_msgTypes,
	}.Build()
	File_plugin_v1_handshake_proto = out.File
	file_plugin_v1_handshake_proto_goTypes = nil
	file_plugin_v1_handshake_proto_depIdxs = nil
}
